<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端每周总结--git使用详解]]></title>
    <url>%2Fblog-12.html</url>
    <content type="text"><![CDATA[什么是git? Git是目前世界上最先进的分布式版本控制系统，工作中或多或少会接触到git，基本上掌握git是开发人员的一项必备技能，下面是一些我总结出来的git的信息的和常用的指令。 Git的由来Git是有Linus（Linux之父）用C语言写的一个分布式版本控制系统，相比集中式控制系统有着极大的优势。 Git常用指令初始化操作123git initgit config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 版本回退操作1234567891011git log //查看提交日志 --pretty=oneline（查看简略信息） --graph (分支合并图)git reset --hard HEAD^ //回退到上一个版本，也可以 HEAD~1git reset --hard &lt;commit_id&gt; //根据提交ID回退版本git reflog //查看历史命令git checkout -- &lt;file&gt; // 丢弃工作区的修改，即用版本库替换工作区git reset HEAD &lt;file&gt; // 把缓存区修改回退到工作区git rm &lt;file&gt; //删除一个文件 远程仓库操作123git remote add origin git@server-name:path/repo-name.git // 关联远程仓库git push -u origin master //第一次推送 master 分支的内容git push origin master || git push // 之后推送命令 分支管理操作12345678910111213141516git branch //查看分支git branch &lt;name&gt; //创建分支git checkout &lt;name&gt; //切换分支git checkout -b &lt;name&gt; //创建和切换分支git merge &lt;name&gt; //合并某分支到当前分支git merge --no-ff -m &quot;annotation&quot; &lt;branch_name&gt; //禁用Fast forward模式,可以在分支历史可出分支信息git branch -d &lt;name&gt; //删除分支git stash // 存储工作现场git stash pop // 回到工作现场git stash list // 查看 stash 工作区列表git branch -d &lt;name&gt; //删除分支git branch -D &lt;name&gt; //删除未合并的分支 多人开发操作 一般来说，master分支是主分支，因此要时刻与远程同步；dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步 1234567git remote //查看远程库信息 -v (查看详细信息)git push origin &lt;branch-name&gt; //推送修改的分支git checkout -b branch-name origin/branch-name // 在本地创建和远程分支对应的分支git branch --set-upstream branch-name origin/branch-name //建立本地分支和远程分支的关联 多人开发工作模式 用 git push origin &lt;branch-name&gt; 推送修改 如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 合并 如果有合并冲突，这要根据提示解决冲突，并在本地提交 解决冲突后，再用git push origin &lt;branch-name&gt;再次推送 标签管理操作 本地添加标签操作 1234git tag &lt;tagname&gt; //新建一个标签，默认为HEAD，也可以指定一个commit idgit tag -a &lt;tagname&gt; -m &apos;annotation&apos; //添加标签信息git tag //查看所有标签git tag -d &lt;tagname&gt; // 删除一个本地标签 远程添加标签操作 123git push origin &lt;tagname&gt; // 推送一个本地标签git push origin --tags // 推送全部未推送的本地标签git push origin :refs/tags/&lt;tagname&gt; //删除一个远程标签 提交时忽略特殊文件 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等 忽略编译生成的中间文件、可执行文件等 忽略带有敏感信息的配置文件 举个栗子 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 配置别名有些git命令单词比较难记，而且比较容易出错，这时候可以通过配置别名来提高开发效(tou)率(lan) 一些常用别名配置 123git config --global alias.unstage &apos;reset HEAD&apos;git config --global alias.last &apos;log -1&apos; //查看最新一次提交]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端每周总结--面向对象之原型继承]]></title>
    <url>%2Fbolg-11.html</url>
    <content type="text"><![CDATA[继承是面向对象语言中一个最为人津津乐道的概念，许多OO语言都支持两种继承方式： 接口继承和实现继承。而JavaScript实现继承主要是依靠原型链来实现的，下面通过实例讲述js继承的几种方式 构造函数继承1234567891011function Parent1 () &#123; this.name = &apos;parent1&apos;;&#125;Parent1.prototype.say = function () &#123;console.log(&apos;say&apos;)&#125;;function Child1 () &#123; Parent1.call(this); this.type = &apos;child1&apos;;&#125;console.log(new Child1()); 上述代码输出结果是：1234Child1 &#123;name: &quot;parent1&quot;, type: &quot;child1&quot;&#125;name: &quot;parent1&quot;type: &quot;child1&quot;__proto__: Object 缺点： 实例没有继承父类的原型 原型链继承123456789101112function Parent2 () &#123; this.name = &apos;parent2&apos;; this.play = [1, 2, 3];&#125;function Child2 () &#123; this.type = &apos;child2&apos;;&#125;Child2.prototype = new Parent2();var s1 = new Child2();var s2 = new Child2();console.log(s1, s2); 输出结果： 12345678910111213141516171819Child2 &#123;type: &quot;child2&quot;&#125;type: &quot;child2&quot;__proto__: Parent2name: &quot;parent2&quot;play: (3) [1, 2, 3]__proto__:say: ƒ ()constructor: ƒ Parent2()__proto__: Object Child2 &#123;type: &quot;child2&quot;&#125;type: &quot;child2&quot;__proto__: Parent2name: &quot;parent2&quot;play: (3) [1, 2, 3]__proto__:say: ƒ ()constructor: ƒ Parent2()__proto__: Object 可以看出实例继承了父类的所有属性，包括其原型 缺点： 引用类型值得原型属性被所有实例共享 组合继承12345678910111213function Parent3 () &#123; this.name = &apos;parent3&apos;; this.play = [1, 2, 3];&#125;function Child3 () &#123; Parent3.call(this); this.type = &apos;child3&apos;;&#125;Child3.prototype = new Parent3();var s3 = new Child3();var s4 = new Child3();s3.play.push(4);console.log(s3.play, s4.play); 输出结果： 1s3.play: 1,2,3,4, s4.play: 1,2,3 组合继承方式解决了原型链继承的缺点，但是有上述代码看出，该继承方式两次调用父类函数，这是不合理。 组合继承优化 – 原型式组合继承1234567891011function Parent4 () &#123; this.name = &apos;parent4&apos;; this.play = [1, 2, 3];&#125;function Child4 () &#123; Parent4.call(this); this.type = &apos;child4&apos;;&#125;Child4.prototype = Parent4.prototype;var s5 = new Child4();var s6 = new Child4(); 上述代码解决了组合继承方式的缺点，是不是这种继承方式是完美的呢？因为实力原型引用父类原型，这会引发新的问题： 12console.log(s5 instanceof Child4, s5 instanceof Parent4);console.log(s5.constructor); 上述代码输出结果是： 12345true trueƒ Parent4 () &#123; this.name = &apos;parent4&apos;; this.play = [1, 2, 3];&#125; 缺点：这种方式无法判断子类是有哪个父类实例出来的，而且子类的contructor属性指向父类函数，而非子构造函数。 组合继承优化 – 寄生组合式继承12345678910function Parent5 () &#123; this.name = &apos;parent5&apos;; this.play = [1, 2, 3];&#125;function Child5 () &#123; Parent5.call(this); this.type = &apos;child5&apos;;&#125;Child5.prototype = Object.create(Parent5.prototype);Child5.prototype.constructor = Child5; 通过Object.create()方法创建父类原型副本，完美解决了上述继承方式的缺点。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端每周总结--跨域那些事]]></title>
    <url>%2Fblog-10.html</url>
    <content type="text"><![CDATA[何为“跨域”，其实是源自浏览器的同源策略，当请求发起的页面所在的URL与访问的接口存在协议，域名或者端口中任意一个不同即视为跨域。当我们需要跨域请求资源时，怎么解决这个问题呢？ 如图所示 这是一个常见的跨域请求报错页面，相信大家都有见过。当我们需要跨域请求资源时，怎么解决这个问题呢？ jsonp下面一步步讲解怎样用jsonp实现跨域 首先开启一个后台服务 编写后端代码1234567891011var http = require(&apos;http&apos;);var url = require(&apos;url&apos;);var PORT = 8081;var server = http.createServer(function (request, response) &#123; response.end(&quot;hello world&quot;);&#125;)server.listen(PORT, function () &#123; console.log(&apos;服务启动成功，正在监听：&apos;, PORT);&#125;) 编写前端代码 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jsonp 跨域&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;跨域 test&lt;/h1&gt; &lt;script type=&quot;text/javascript&quot;&gt; var xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;, &apos;http://localhost:8081/&apos;); xhr.send(); &lt;/script&gt; （备注：live-server是一个提供服务器环境的插件，支持HTML热更新） 然后熟悉的报错就出现了… 因为同源策略对script外域资源加载不受限制，所以再修改一下代码 后端代码 1234567891011var http = require(&apos;http&apos;);var url = require(&apos;url&apos;);var PORT = 8081;var server = http.createServer(function (request, response) &#123; response.end(&quot;var jsonpTest = &#123;name: &apos;billy&apos;&#125;&quot;);&#125;)server.listen(PORT, function () &#123; console.log(&apos;服务启动成功，正在监听：&apos;, PORT);&#125;) 前端代码 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jsonp 跨域&lt;/title&gt; &lt;script src=&apos;http://localhost:8081/&apos;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;跨域 test&lt;/h1&gt; &lt;script type=&quot;text/javascript&quot;&gt; console.log(window.jsonpTest) &lt;/script&gt; 并重启一下后台服务，在看一下控制台 1&#123;name: &quot;billy&quot;&#125; 已经成功获取到数据了 现在jsonp跨域原理已经有所了解了，下面将实现封装起来 12345678910111213141516171819202122232425262728293031323334function Jsonp(url, cb) &#123; this.callbackName = &apos;jsonp_&apos; + Date.now(); this.cb = cb; this.url = url; this.init();&#125;Jsonp.prototype.init = function () &#123; if (~this.url.indexOf(&apos;?&apos;)) &#123; this.url = this.url + &apos;&amp;callback=&apos; + this.callbackName; &#125; else &#123; this.url = this.url + &apos;?callback=&apos; + this.callbackName; &#125; this.createCallBack(); this.createScript();&#125;Jsonp.prototype.createScript = function () &#123; var script = document.createElement(&apos;script&apos;); script.src = this.url; script.onload = function () &#123; // this.remove(); delete window[this.callbackName]; &#125; document.body.appendChild(script);&#125;Jsonp.prototype.createCallBack = function () &#123; window[this.callbackName] = this.cb;&#125;new Jsonp(&apos;http://localhost:8081/&apos;, function(data) &#123; console.log(data);&#125;) 后台代码做一些修改 12345678910111213var http = require(&apos;http&apos;);var url = require(&apos;url&apos;);var PORT = 8081;var server = http.createServer(function (request, response) &#123; var queryObj = url.parse(request.url, true).query; // 获取回调函数名进行调用 response.end(`$&#123;queryObj.callback&#125;(&#123;name: &apos;billy&apos;&#125;)`);&#125;)server.listen(PORT, function () &#123; console.log(&apos;服务启动成功，正在监听：&apos;, PORT);&#125;) 重启后台服务 至此，能顺利跨域获取到数据； nginx跨域举个栗子： 前端域名为： fe.server.com 后端服务的域名为： dev.server.com 当前端向后端发起请求时一定会出现跨域报错 解决办法 在后台启动一个nginx服务器，将server_name 设置为fe.server.com，这里我选择监听81端口，然后设置相应的location以拦截前端需要的跨域请求，最后将请求代理回 dev.serveer.com 1234567server &#123; listen: 81; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125;&#125; 这样就可以绕过浏览器的同源策略了 CORSCORS是一个W3C标准，全称是“跨域资源共享” （Cross-origin-resource-sharing），它允许浏览器向跨源服务器发起XMLHttpRequest请求。 服务器设置Access-Control-Allow-Origin就可以开启CORS，如下： 123456app.all(&apos;*&apos;, function (req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); next();&#125;); postMessage跨域postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递 举个栗子： 1234567891011121314151617181920//向某个iframe发送信息var domain = &apos;http://blog.sharelab.club&apos;;var iframe = document.getElementById(&apos;myIframe&apos;).contentWindow;//发送消息sendIntervalMessage();function sendIntervalMessage() &#123; var message = &apos;Hello， the time is&apos; + new Date(); iframe.postMessage(message, domain); setTimeout(function () &#123; arguements.callee(); &#125;, 5000);&#125;//响应事件window.addEventListener(&apos;message&apos;,function(event) &#123; if(event.origin !== &apos;http://davidwalsh.name&apos;) return; console.log(&apos;message received: &apos; + event.data,event); event.source.postMessage(&apos;I received!&apos;,event.origin);&#125;,false); postMessage跨域适用于以下场景：同浏览器多窗口间跨域通信、iframe间跨域通信。 webSocketwebSocket是一种双向通信协议，在建立连接后，webSocket的server与client都能主动向对方发送或接收数据而不受同源策略的限制。 123456789101112131415161718192021function WebSocketTest()&#123; if (&quot;WebSocket&quot; in window)&#123; alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:8080/&quot;); ws.onopen = function()&#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function()&#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125; else&#123; alert(&quot;您的浏览器不支持 WebSocket!&quot;); &#125;&#125; 以上是我了解到的跨域方式]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端每周总结--js最优数组去重]]></title>
    <url>%2Fblog-09.html</url>
    <content type="text"><![CDATA[最近回顾前端学习基础，决定每周写一篇有关前端的总结博客；数组去重是一个常被提及的问题，之前有接触过几种数组去重方法，加上最近学习ES6新特性后，发现数组去重有了更多的选择，但是哪种数组去重是最优解呢？下面通过实践来测试。 为了说明问题，写一个测试模板用来计算数组去重耗时。 123456789101112131415161718var arr1 = Array.from(new Array(100000), (x, index) =&gt; &#123; return index;&#125;);var arr2 = Array.from(new Array(50000), (x, index) =&gt; &#123; return index + index;&#125;)function removal () &#123;&#125;var start = new Date().getTime();console.log(&apos;开始去重&apos;);console.log(&apos;剩余长度&apos;, removal(arr1, arr2).length);var end = new Date().getTime();console.log(&apos;耗时&apos;, end - start, &apos;ms&apos;); 双重for循环去重12345678910111213function removal1(a, b) &#123; var arr = a.concat(b); for (var i=0, len=arr.length; i&lt;len; i++) &#123; for (var j=i+1; j&lt;len; j++) &#123; if (arr[i] == arr[j]) &#123; arr.splice(j, 1); len--; j--; &#125; &#125; &#125; return arr;&#125; 测试结果:18秒耗时，可以看出双重for循环去重效率很低，用数据结构的表述来说，这种去重方式时间复杂度过高 Array.filter() + indexOf123456function removal2(a, b) &#123; var arr = a.concat(b); return arr.filter((item, index) =&gt; &#123; return arr.indexOf(item) == index; &#125;)&#125; 代码比上一个简洁一些，看一下耗时怎样 测试结果： 效率还是有点低。。 for…of + includes()12345678function removal4(a, b) &#123; let arr = a.concat(b); let newArr = []; for (let i of arr) &#123; !arr.includes(i) &amp;&amp; newArr.push(arr[i]); &#125; return newArr;&#125; 使用Array.includes()判断是否存在，可用indexOf代替 测试结果： 这种去重方式与使用filter + indexOf 类似，所以耗时差不多一样 Array.sort()先将数组排序，然后通过循环与相邻数据比较。 123456789function removal3(a, b) &#123; var arr = a.concat(b); arr.sort(); var newArr = [arr[0]]; for (var i=1; i&lt;arr.length; i++) &#123; arr[i] !== arr[i-1] &amp;&amp; newArr.push(arr[i]); &#125; return newArr;&#125; 测试结果： 耗时比前面几种低很多，因为时间复杂度较低，只用了一次循环 new Set()1234function removal5(a, b) &#123; // return Array.from(new Set([...a, ...b])); return [...new Set([...a, ...b])];&#125; Set类似数组结构，成员具有唯一性，利用这种特性来去重；代码非常简洁，看一下去重效率怎么样 测试结果： 只要34毫秒！这种去重方法真的简洁又高效。 for…of + Object最后一种去重方式，创建一个空对象，利用对象属性不重复特性，检查实现数组去重 123456789101112function removal6(a, b) &#123; let arr = a.concat(b); let object = &#123;&#125;; let newArr = []; for (let i of arr) &#123; if (!object[i]) &#123; newArr.push(arr[i]); object[i] = 1; &#125; &#125; return newArr; &#125; 既然放到最后，肯定效果不一般，来看看测试表现怎样 竟然只用了21毫秒，比Set方式还快！ 总结对于数组去重，尽量减少for循环，减低时间复杂度（最近学习数据结构课程了解到的名词），效率就会有所提升。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客优化--解决跨域请求问题、gulp压缩、站点图片添加水印]]></title>
    <url>%2Fblog-08.html</url>
    <content type="text"><![CDATA[在上一篇博客有提到，个人音乐播放器在网站使用https协议访问时无法获取数据，其原因是后台搭建的音乐数据接口是http协议的，若博客使用https协议就会造成网络协议不同，浏览器同源策略是不允许这样的跨域请求。（除了协议不同会造成跨域，域名、端口与当前页面地址不同也为跨域） 本篇文章将做下列事情 解决跨域请求问题 使用gulp压缩代码提升性能 站点图片添加水印 解决跨域请求问题当用HTTP协议访问本站点时会出现如图报错：无法通过http协议获取最近音乐播放数据 解决思路： 获取SSL证书，将请求接口换成https协议 通过Nginx代理音乐接口 首先创建一个域名解析记录，这里我创建一个以music为开头的二级域名，并将记录值指向服务器IP地址 获取SSL免费证书并下载证书到本地 连接远程服务器，复制SSL证书到Nginx的conf目录，然后对nginx.conf文件进行配置（因为我是使用Nginx代理服务器，所以我这里选择Nginx证书） (备注： http://localhost:163 是我在后台开启的音乐数据接口) 完成后将js音乐数据请求url换成新的url : https://music.sharelab.club 至此博客跨域请求问题解决了。 使用gulp压缩代码提升站点性能什么是gulp?gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器。不仅能对网站的资源进行优化，并且能在开发过程中能够对很多重复的任务使其自动完成。 (注意： gulp是基于node环境,所以要首先安装nodejs) 安装gulp及其插件 gulp-htmlclean // 清理html gulp-htmlmin // 压缩html gulp-minify-css // 压缩css gulp-uglify // 混淆js gulp-imagemin // 压缩图片 在根目录执行命令npm install gulp@3.9.1 --save安装gulp 接着执行命令npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save或者npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save-dev (区别是： -dev安装的包会保存至package.json的devDependencies节点，是存放开发所依赖的包；–save将配置信息保存在package.json中的dependencies节点，是程序正常运行所需要安装的依赖) 打开package.json文件若有:123456 &quot;gulp&quot;: &quot;^3.9.1&quot;,&quot;gulp-htmlclean&quot;: &quot;^2.7.22&quot;,&quot;gulp-htmlmin&quot;: &quot;^4.0.0&quot;,&quot;gulp-imagemin&quot;: &quot;^4.1.0&quot;,&quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;,&quot;gulp-uglify&quot;: &quot;^3.0.1&quot;, 表明安装依赖成功 创建gulpfile.js文件在根目录下，新建gulpfile.js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);var imagemin = require(&apos;gulp-imagemin&apos;); // 压缩htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss(&#123; compatibility: &apos;ie8&apos; &#125;)) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/js/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩图片gulp.task(&apos;minify-images&apos;, function() &#123; return gulp.src(&apos;./public/images/**/*.*&apos;) .pipe(imagemin( [imagemin.gifsicle(&#123;&apos;optimizationLevel&apos;: 3&#125;), imagemin.jpegtran(&#123;&apos;progressive&apos;: true&#125;), imagemin.optipng(&#123;&apos;optimizationLevel&apos;: 7&#125;), imagemin.svgo()], &#123;&apos;verbose&apos;: true&#125;)) .pipe(gulp.dest(&apos;./public/images&apos;))&#125;);// 默认任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;]) （注意：若gulp版本为4以上会运行该代码会报错，因为gulp4不能像以前上面代码那样传递一个依赖任务列表。） 最后在根目录执行命令gulp 此时代码已经成功压缩了。 站点图片添加水印给站点上的图片加上水印，比如把自己博客的网址加上去，这样比较利于保护自己的原创及版权，还能够让别人采集后，可以起到宣传作用。 注册七牛云，使用其对象存储服务 这里还有很多处理方式，比如缩放方式、裁剪、增加图片水印、设置输出格式，使用起来非常方便！]]></content>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客优化--添加个人音乐播放器]]></title>
    <url>%2Fblog-07.html</url>
    <content type="text"><![CDATA[我之前打算用Vue框架来写一个网易云音乐webApp，但感觉自己功底不够，等修炼多一段时间在尝试写。现在有了这个个人博客，所以就写了一个简单的音乐播放器插件，放在博客侧边栏，歌曲数据是我网易云音乐最近播放记录，下面是搭建过程。 先上效果图 侧边栏空间有限，一次只显示四首歌曲，点击刷新可随机显示4四首最近播放记录的音乐。 注意：移动端暂时无法显示播放器；可点击这里访问404页面 如图： 前记虽然可以直接在博客上面添加网易云音乐站外播放外链，但是只能播放一首歌曲，而且不能用js操控播放； 所以就放弃这种方案，直接自己动手搭建一个音乐播放插件，可以在其他地方直接调用。 技术栈： HTML5 (使用HTML5标签 data- 属性绑定数据) CSS3 (使用CSS3做音乐播放动画) jQuery 开启后台服务器网易云接口是使用github上的一个NodeJs API，用git将仓库代码下载到本地服务器上，在git bash使用命令node app.js即可开启接口服务 编辑静态页面及用js获取数据显示 在博客根目录找到themess文件夹，找到自己所需的地方编辑页面代码 我选择添加在博客侧边栏，HTML代码如下: 123456789101112131415161718192021222324252627282930&lt;div class=&quot;my-music&quot;&gt; &lt;!-- 渐变条 --&gt; &lt;span class=&quot;hr&quot;&gt;&lt;/span&gt; &lt;div class=&quot;my-music_title&quot;&gt; &lt;p&gt;&lt;i class=&quot;fa fa-headphones&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;最近在听&lt;/p&gt; &lt;p class=&quot;reflash-music&quot;&gt;刷新&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;music-player&quot;&gt; &lt;div class=&quot;music-player_logo&quot;&gt; &lt;/div&gt; &lt;div class=&quot;music-player_txt ellipsis&quot;&gt;音乐播放器&lt;/div&gt; &lt;div class=&quot;music-player-control&quot;&gt;&lt;/div&gt; &lt;audio src=&quot;&quot; hidden&gt;&lt;/audio&gt; &lt;/div&gt; &lt;ul class=&quot;my-music_list&quot;&gt; &lt;!-- 播放动画 --&gt; &lt;div class=&quot;my-music_list-current preloader_1&quot;&gt; &lt;span class=&quot;preloader_1-m1&quot;&gt;&lt;/span&gt; &lt;span class=&quot;preloader_1-m2&quot;&gt;&lt;/span&gt; &lt;span class=&quot;preloader_1-m3&quot;&gt;&lt;/span&gt; &lt;span class=&quot;preloader_1-m1&quot;&gt;&lt;/span&gt; &lt;span class=&quot;preloader_1-m2&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/ul&gt; &lt;span class=&quot;hr&quot;&gt;&lt;/span&gt;&lt;/div&gt; CSS代码如下 123456789.hr &#123; display: block; margin: 10px 0 0; height: 3px; border: none; background-color: #ddd; box-sizing: border-box; background-image: repeating-linear-gradient(-45deg, #69bce1, #69bce1 4px, transparent 4px, transparent 8px);&#125; (使用CSS3 linear-gradient做的一个渐变条，放在播放器上下两端) 123456789101112131415161718192021222324252627282930.preloader_1 &#123; width: 30px; height: 20px; margin: 0;&#125;.preloader_1 span &#123; float: left; width: 3px; height: 20px; background-color: blue; margin-left: 2px;&#125;.preloader_1-m1 &#123; animation: living .8s linear infinite; animation-delay: -1.1s;&#125;.preloader_1-m2 &#123; animation: living .8s linear infinite; animation-delay: -1.3s;&#125;.preloader_1-m3 &#123; animation: living .8s linear infinite; animation-delay: -1.6s;&#125;@keyframes living &#123; 0% &#123; transform: scaleY(1); transform-origin: 0 20px; background:#9b59b6; &#125; 50% &#123; transform: scaleY(.3); transform-origin: 0 20px; background:#69bce1; &#125; 100% &#123; transform: scaleY(1); transform-origin: 0 20px; background:#9b59b6;&#125;&#125; (使用CSS3 animation做一个音乐播放动效)其他css代码比较简单就不放上了。 js 逻辑代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940//使用立即执行函数，可防止音乐播放器的变量及函数名污染全局变量(function () &#123; // 音乐播放器局部变量 var allMusic = [], musicLis = [], ifPlay = false, ids = [], currentPlay = 0, ramdomCount = 0; getMusicData(); // 监听点击 function spyClick() &#123; ... &#125; // 播放音乐 function playMusic() &#123; ... &#125; // 获取数据 function getMusicData() &#123; ... &#125; // 随机显示四首播放音乐 function showRamdomData() &#123; ... &#125; // 处理根据多个音乐id获取的音乐url数据顺序不一样的问题 function resetList(arr, target) &#123; ... &#125;&#125;)($) 总结 做完这个音乐播放器感觉有了一些经验了，等有时间尝试做一个网易云音乐webApp。 待解决：目前只能通过HTTP协议访问本博客才能获取音乐数据，HTTPS访问会有跨域请求问题，计划使用jQuery的jsonp请求回调解决这个问题。]]></content>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人作品--美图屋]]></title>
    <url>%2Fblog-05.html</url>
    <content type="text"><![CDATA[学习了一段时间前端，找不到什么项目来练手，自己对后端了解的不多，所以就在网上找一些数据接口来开发了这个项目，这个项目用到了360壁纸、必应每日美图、金山词霸开发者平台的数据api。 功能 在线美图网站，多种壁纸分类，支持多种图片尺寸下载 技术栈： jQuery （用jQuery来获取DOM; ajax跨域请求;） PHP （用PHP集中判断并发送请求，实现跨域请求） 服务器 （在服务器上搭建nginx + PHP环境，部署上线） 响应式 （适配PC端及移动端） 传送门 页面展示：]]></content>
      <tags>
        <tag>作品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人作品--小米9宣传页面]]></title>
    <url>%2Fblog-06.html</url>
    <content type="text"><![CDATA[最近小米9手机发布，感觉还不错，个人比较喜欢小米MIUI系统，所有就做了这个页面。 技术栈 HTML5 / CSS3 （主要用来做页面动效交互） PC端 （本页面不适配移动端） 传送门 页面展示： 待解决问题: 暂时不适配移动端 某些浏览器不能显示全部内容，可能是不兼容CSS3动画属性]]></content>
      <tags>
        <tag>作品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人作品--海报]]></title>
    <url>%2Fblog-03.html</url>
    <content type="text"><![CDATA[我从大一开始就喜欢折腾一些软件或者有关页面设计的东西，看到网上别人做的海报很酷炫，所以自学了PPT、PS,做了一些简单的海报（可能不算是海报吧，自己瞎折腾），感觉自己还是缺少了一些审美，记录在这里。]]></content>
      <tags>
        <tag>作品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人作品--微生活Lite(小程序)]]></title>
    <url>%2Fblog-04.html</url>
    <content type="text"><![CDATA[之前小程序很火，感觉开发起来也比较方便，所以就借了本书学习开发小程序，做出了这个小程序，感觉小程序和Vue有点类似，都有生命周期（小程序钩子相对简单）、数据双向绑定、组件通信。 功能 微豆瓣 （实时豆瓣各类榜单，提供豆瓣评分和评论信息，支持搜索，支持发表影评） 微天气 （实时天气信息，支持查看不同地点天气） 微相册 （类似微信朋友圈的相册，记录生活的点滴） 图片展示 技术栈：小程序 | 云开发 扫码体验：]]></content>
      <tags>
        <tag>作品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白的第一篇博客]]></title>
    <url>%2Fblog-01.html</url>
    <content type="text"><![CDATA[折腾了几天，终于把博客弄好了，从大二暑假开始入坑前端开发，一直想做一个属于自己的博客网站，主要是用来记录学习过程中遇到的技术难题和踩过的坑，同时还可以记录自己的成长经历，以后看看也许有所感触吧。万事开头难，现在总算迈出第一步，希望以后能坚持写博客。 博客的搭建本来想自己动手开发一个博客，但最近有点忙，加上想找一份实习，要去准备。所以就用了hexo + github pages搭建了这个博客，搭建过程中也踩了不少坑，网上有很多搭建过程文章，但是不够详细或者有错误，等有时间我再总结一下搭建过程。 未来打算 及时总结，随时记录理解（之前学习过程中，没有注重总结，有些知识学了不久就忘） 写有深度的博客，做一些优秀项目（这点有待努力，感觉自己还是前端小白，要多学习多总结） 找一份实习（毕竟自己自学缺少一些方向和实践） 持续不断地学习，近期打算深度学习Vue开发一个项目]]></content>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
</search>
